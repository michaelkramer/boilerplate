'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _util = require('util');

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _store = require('./store');

var _store2 = _interopRequireDefault(_store);

var _errors = require('./errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var UP = 'up';
var DOWN = 'down';

var MIGRATION_PATTERN = /^\d{14}_[A-Za-z0-9\-]+\./;
var MIGRATION_NAME_FILTER = /[^A-Za-z0-9\-]+/g;

function pathExists(pth) {
  return new _bluebird2.default(function (resolve, reject) {
    _fs2.default.exists(pth, function (exists) {
      resolve(exists);
    });
  });
}

function pad(str) {
  return _lodash2.default.padLeft(String(str), 2, '0');
}

function timestamp() {
  var d = new Date();

  return d.getFullYear().toString() + pad(d.getMonth() + 1) + pad(d.getDate()) + pad(d.getHours()) + pad(d.getMinutes()) + pad(d.getSeconds());
}

var Migrate = function () {
  function Migrate(options) {
    var _this = this;

    _classCallCheck(this, Migrate);

    (0, _assert2.default)(_lodash2.default.isString(options.directory), 'Migrate must be passed a migrations directory');
    this.migrationsDir = options.directory;

    if (options.backendStore) {
      this.setStore(options.backendStore, options);
    } else {
      throw new Error('No backend provided for persistence');
    }

    (0, _assert2.default)(this.store instanceof _store2.default, 'Specified backend is not an instance of Mariner#Store');

    options.dialects = _lodash2.default.mapValues(options.dialects, function (Dialect, key) {
      return new Dialect(_this, options[key] || {}, options);
    });

    this.options = options;
  }

  _createClass(Migrate, [{
    key: 'init',
    value: function init() {
      var _this2 = this;

      var options = this.options;

      return pathExists(this.migrationsDir).then(function (exists) {
        if (!exists) {
          throw new _errors.MigrationsDirectoryNotFoundError();
        }

        return _fs2.default.readdirAsync(_this2.migrationsDir);
      }).then(function (migrationFiles) {
        _this2.migrations = _lodash2.default.filter(migrationFiles, function (file) {
          if (!_this2.getDialect(file)) {
            var warning = _chalk2.default.yellow(_chalk2.default.red('[WARNING]') + ' skipping ' + file + ', no dialect/plugin');

            if (_this2.options.stopOnWarning) {
              throw new _errors.DialectUnknown(_this2.getDialectFromFile(file));
            } else {
              console.log(warning); // eslint-disable-line no-console
            }
          }

          return file.match(MIGRATION_PATTERN);
        });
      }).then(function () {
        return _this2.store.init(_lodash2.default.get(options, options.backend, {}));
      });
    }
  }, {
    key: 'setStore',
    value: function setStore(store) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? this.options : arguments[1];

      if (_lodash2.default.isFunction(store)) {
        var storeOptions = options[options.backend] || {};

        storeOptions.isBackend = true;

        store = new store(storeOptions, options);
        store.init = _bluebird2.default.method(store.init.bind(store));
      }

      (0, _assert2.default)(store instanceof _store2.default, 'store must be an instance of Store');

      this.store = store;
    }
  }, {
    key: 'computeUpDiff',
    value: function computeUpDiff() {
      var _this3 = this;

      return this.store.list().then(function (migrations) {
        // Ensure all the migrations in the database exist
        var missing = _lodash2.default.difference(migrations, _this3.migrations);

        if (missing.length) {
          throw new _errors.MigrationMissingError(missing);
        }

        var newMigrations = _lodash2.default.difference(_this3.migrations, migrations);

        // Migrations should be sorted, but _.difference does not document stability
        newMigrations.sort();

        return newMigrations;
      });
    }
  }, {
    key: 'getDownCandidates',
    value: function getDownCandidates() {
      return this.store.list().then(function (migrations) {
        return migrations.reverse();
      });
    }
  }, {
    key: 'run',
    value: function run(direction) {
      var _this4 = this;

      var count = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

      var promise = void 0;

      (0, _assert2.default)(direction === UP || direction === DOWN, 'direction must be one of: up, down');

      if (count !== null) {
        if (!_lodash2.default.isNumber(count) || count <= 0) {
          throw new Error('count must be a positive integer when provided');
        }
      }

      if (direction === 'up') {
        promise = this.computeUpDiff().then(function (migrations) {
          if (count) {
            migrations = migrations.slice(0, count);
          }

          return _bluebird2.default.each(migrations, function (name) {
            return _this4.runOne(direction, name);
          });
        });
      } else {
        promise = this.getDownCandidates().then(function (migrations) {
          if (!count) {
            count = 1;
          }

          migrations = migrations.slice(0, count);

          return _bluebird2.default.each(migrations, function (name) {
            return _this4.runOne(direction, name);
          });
        });
      }

      return promise;
    }
  }, {
    key: 'runOne',
    value: function runOne(direction, name) {
      var _this5 = this;

      (0, _assert2.default)(direction === UP || direction === DOWN, 'direction must be one of: up, down');

      var dialect = this.getDialect(name);

      (0, _assert2.default)(dialect, 'unknown dialect for migration file: ' + name);

      var migrate = _bluebird2.default.method(dialect.migrate.bind(dialect));

      return migrate(direction, name).then(function () {
        return direction === UP ? _this5.store.record(name) : _this5.store.delete(name);
      }).tap(function () {
        if (direction === UP) {
          console.log('⛵\tUP: %s', name); // eslint-disable-line no-console
        } else {
          console.log('⛵\tDOWN: %s', name); // eslint-disable-line no-console
        }
      }).catch(function (e) {
        throw new _errors.RuntimeMigrationError(name, e);
      });
    }
  }, {
    key: 'getDialectFromFile',
    value: function getDialectFromFile(file) {
      return _path2.default.extname(file).replace('.', '');
    }
  }, {
    key: 'getDialect',
    value: function getDialect(name) {
      var ext = this.getDialectFromFile(name);

      return _lodash2.default.find(this.options.dialects, function (dialect) {
        return dialect.constructor.check(ext);
      });
    }
  }, {
    key: 'getMigrationPath',
    value: function getMigrationPath(name) {
      return _path2.default.join(this.migrationsDir, name);
    }
  }, {
    key: 'getMigrationContent',
    value: function getMigrationContent(direction, name) {
      var filename = this.getMigrationPath(name);

      return _fs2.default.readFileAsync(filename, { encoding: 'utf8' });
    }

    /**
     * Creates a new migration in the migrations directory from the stub using the
     * given name.
     *
     * File name format:
     *   YYYYMMDDHHMMSS_migration-name.sql
     *
     * Any non-alphanumeric characters in name will be replaced with dashes.
     *
     * @param  {string} name Migration name
     * @return {Promise}
     */

  }, {
    key: 'create',
    value: function create(name, options) {
      var _this6 = this;

      var filename = (0, _util.format)('%s_%s.%s', timestamp(), name.replace(MIGRATION_NAME_FILTER, '-'), options.extension);

      var destPath = _path2.default.join(this.migrationsDir, filename);

      return pathExists(this.migrationsDir).then(function (exists) {
        return exists ? null : _fs2.default.mkdir(_this6.migrationsDir);
      }).then(function () {
        return pathExists(destPath);
      }).then(function (exists) {
        if (exists) {
          throw new _errors.MigrationExistsError();
        }

        return _this6.getDialect(filename);
      }).then(function (dialect) {
        if (!dialect) {
          throw new _errors.DialectUnknown(options.extension);
        }

        return dialect.create(destPath, options);
      });
    }
  }]);

  return Migrate;
}();

exports.default = Migrate;